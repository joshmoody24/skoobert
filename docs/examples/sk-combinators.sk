// SK Combinator Calculus
// The foundation of computation using only two combinators

// Basic combinators
let S = x => y => z => x(z)(y(z));
let K = x => y => x;

// The identity combinator derived from S and K
let I = S(K)(K);

console.log("Testing basic combinators:");
console.log("Identify combinator: 42 = " + I(42));            // Identity: returns 42
console.log("Kestral combinator: K(10)(20) = " + K(10)(20));  // Constant: returns 10

// More derived combinators (with their lambda forms)
let B = S(K(S))(K);          // Bluebird:    x => y => z => x(y(z))     - composition
let C = S(B(B)(S))(K(K));    // Cardinal:    x => y => z => x(z)(y)     - flip last two arguments
let W = S(S)(K(I));          // Warbler:     x => y => x(y)(y)          - duplicate argument
let M = S(I)(I);             // Mockingbird: x => x(x)                  - self-application
let T = C(I);                // Thrush:      x => y => y(x)             - flip arguments
let V = B(C)(T);             // Vireo:       x => y => z => z(x)(y)     - move last argument to front
let R = B(B)(T);             // Robin:       x => y => z => y(z)(x)     - move middle argument to front
let B1 = B(B)(B);            // Blackbird:   x => y => z => w => x(y(b)(w))
let E = B(B1);               // Eagle:       x => y => z => w => v => x(y)(z(w(v)))

let R_STAR = C_STAR(C_STAR); // Robin once removed:     x => y => z => w => x(z)(w)(y)          - AKA R*
let C_STAR = B(C);           // Cardinal once removed:  x => y => z => w => x(y)(w)(z)          - AKA C*
let C_STAR_STAR = B(C_STAR); // Cardinal twice removed: x => y => z => w => v => x(y)(z)(v)(w)  - AKA C**


// Boolean logic using combinators
let TRUE = K;      // given two things, choose the first
let FALSE = K(I);  // given two things, choose the second
let IF = I;

let toBoolean = (x) => x(true)(false);

let NOT = V(FALSE)(TRUE); // NOT = p => p(FALSE)(TRUE);

console.log("\nBoolean logic:");
console.log("NOT true = " + toBoolean(NOT(TRUE)));
console.log("NOT false = " + toBoolean(NOT(FALSE)));

// let AND = p => q => p(q)(FALSE); Vireo?
// let OR = p => q => p(TRUE)(q);

// Lazy evaluation test - M(M) would diverge with eager evaluation
console.log("\nLazy evaluation test:");
console.log(K(42)(M(M)) + " (this would throw an error in normal JavaScript)");  // Returns 42 without evaluating M(M)

// Barendregt numerals
let ZERO = I;
let IS_ZERO = T(TRUE);      // IS_ZERO n = n TRUE
let SUCC = V(FALSE);        // SUCC n = V FALSE n
let PRED = T(FALSE);        // PRED n = n FALSE
let DECREMENT = m => IS_ZERO(m)(m)(PRED(m)); // Clamped version of PRED

// Build some numbers
let ONE   = SUCC(ZERO);
let TWO   = SUCC(ONE);
let THREE = SUCC(TWO);
let FOUR  = SUCC(THREE);
let FIVE  = SUCC(FOUR);
let SIX   = SUCC(FIVE);
let SEVEN = SUCC(SIX);
let EIGHT = SUCC(SEVEN);
let NINE  = SUCC(EIGHT);
let TEN   = SUCC(NINE);

// Convert Barendregt numeral to JavaScript number
let toNumber = m => IS_ZERO(m)(0)(1 + toNumber(PRED(m)));

console.log("\nBarendregt/Scott numerals:");
console.log("One: " + toNumber(ZERO));   // 0
console.log("Three: " + toNumber(THREE));  // 3
console.log("Five: " + toNumber(FIVE));   // 5

// Y combinator for recursion
// let Y = f => (x => f(x(x)))(x => f(x(x)));
let Y = W(C)(S(B)(C(W(C))));

// TODO combinator version
let NUMBER_EQUALS = x => y =>
  IS_ZERO(x)
    (IS_ZERO(y)
       (TRUE)
       (FALSE))
    (IS_ZERO(y)
       (FALSE)
       (NUMBER_EQUALS(PRED(x))(PRED(y))));

console.log("\nNumber equality:");
console.log("5 == 5 = " + toBoolean(NUMBER_EQUALS(FIVE)(FIVE)));
console.log("1 == 2 = " + toBoolean(NUMBER_EQUALS(ONE)(TWO)));

// Addition
// Starting from Lambda Calculus (more readable, way less metal)
// let ADD = m => n => IS_ZERO(m)(n)(SUCC(ADD(PRED(m))(n)));
// First eliminate n
// ADD(m)(n) = IS_ZERO(m)(n)(SUCC(ADD(PRED(m))(n)))
// ADD(m)(n) = B(IS_ZERO(m)(n))(SUCC)(ADD(PRED(m))(n))
// ADD(m)(n) = B(B)(IS_ZERO(m))(n)(SUCC)(ADD(PRED(m))(n))
// ADD(m)(n) = C(B(B)(IS_ZERO(m)))(SUCC)(n)(ADD(PRED(m))(n))
// ADD(m)(n) = S(C(B(B)(IS_ZERO(m)))(SUCC))(ADD(PRED(m)))(n)
// Then eliminate m
// ADD(m)(n) = S(C(B(B(B))(IS_ZERO)(m))(SUCC))(ADD(PRED(m)))(n)
// ADD(m)(n) = S(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)(m))(ADD(PRED(m)))(n)
// ADD(m)(n) = B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))(m)(B(ADD)(PRED)(m))(n)
// ADD(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(B(ADD)(PRED))(m)(n)
// Then eliminate the explicit self reference
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(B(y)(PRED))(m)(n)
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(K(I)(y)(B(y))(PRED))(m)(n)
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(S(K(I))(B)(y)(PRED))(m)(n)
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(C(S(K(I))(B))(PRED)(y))(m)(n)
// ADD_MAKER(y)(m)(n) = B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED))(y)(m)(n)
// ADD_MAKER = B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED))
// ADD = Y(ADD_MAKER)
let ADD = Y(B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED)));

console.log("\nAddition:");
console.log("2 + 3 = " + toNumber(ADD(TWO)(THREE)));  // 5
console.log("4 + 5 = " + toNumber(ADD(FOUR)(FIVE)));  // 9

// Subtraction
// Same as ADD except with DECREMENT instead of SUCC, and wrapped in C to swap the params
let SUBTRACT = C(Y(B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(DECREMENT))))(C(S(K(I))(B))(PRED))));

console.log("\nSubtraction:");
console.log("5 - 2 = " + toNumber(SUBTRACT(FIVE)(TWO)));  // 3
console.log("1 - 3 = " + toNumber(SUBTRACT(ONE)(THREE)) + " (no negatives in this number system)");  // 0


// TODO combinator version
let MULTIPLY = (x) => (y) => IS_ZERO(y)(ZERO)(ADD(x)(MULTIPLY(x)(PRED(y))));

console.log("\nMultiplication:");
console.log("5 * 5 = " + toNumber(MULTIPLY(FIVE)(FIVE)));
console.log("3 * 4 = " + toNumber(MULTIPLY(THREE)(FOUR)));
console.log("2 * 0 = " + toNumber(MULTIPLY(TWO)(ZERO)));

// LESS_THAN_OR_EQUAL(a)(b) = IS_ZERO(SUBTRACT(a)(b))(TRUE)(FALSE)
// LESS_THAN_OR_EQUAL(a)(b) = IS_ZERO(SUBTRACT(a)(b))
// LESS_THAN_OR_EQUAL(a)(b) = B1(IS_ZERO)(SUBTRACT)
let LESS_THAN_OR_EQUAL = B1(IS_ZERO)(SUBTRACT);
let GREATER_THAN_OR_EQUAL = C(LESS_THAN_OR_EQUAL);

console.log("\nLess than or equal:");
console.log("3 <= 2 = " + toBoolean(LESS_THAN_OR_EQUAL(THREE)(TWO)));  // true
console.log("4 <= 5 = " + toBoolean(LESS_THAN_OR_EQUAL(FOUR)(FIVE)));  // false
console.log("0 <= 0 = " + toBoolean(LESS_THAN_OR_EQUAL(FOUR)(FIVE)));  // false

let INVERT_BINARY_RELATION = B1(NOT);
let GREATER_THAN = INVERT_BINARY_RELATION(LESS_THAN_OR_EQUAL);
let LESS_THAN = INVERT_BINARY_RELATION(GREATER_THAN_OR_EQUAL);

console.log("\nGreater than:");
console.log("3 > 2 = " + toBoolean(GREATER_THAN(THREE)(TWO)));  // true
console.log("4 > 5 = " + toBoolean(GREATER_THAN(FOUR)(FIVE)));  // false
console.log("0 > 0 = " + toBoolean(GREATER_THAN(FOUR)(FIVE)));  // false

// TODO: combinator version
let MOD_MAKER = f => m => n => LESS_THAN(m)(n)(m)
(f(SUBTRACT(m)(n))(n));
let MOD = Y(MOD_MAKER);

console.log("\nModulus:");
console.log("5 % 2 = " + toNumber(MOD(FIVE)(TWO)));
console.log("5 % 3 = " + toNumber(MOD(FIVE)(THREE)));
console.log("4 % 2 = " + toNumber(MOD(FOUR)(TWO)));

// let DECIMAL2 = x => y => ADD(MULTIPLY(TEN)(x))(y);
let DECIMAL2 = B(ADD)(MULTIPLY(TEN));

// let DECIMAL3 = x => y => z => ADD(MULTIPLY(ONE_HUNDRED)(DECIMAL2(y)(z))
let ONE_HUNDRED = MULTIPLY(TEN)(TEN);
let DECIMAL3 = C(E(B(ADD)(MULTIPLY(ONE_HUNDRED))))(DECIMAL2);

console.log("\nDecimal numbers:");
console.log("Twenty-six: " + toNumber(DECIMAL2(TWO)(SIX)));
console.log("Two hundred fifty-six: " + toNumber(DECIMAL3(TWO)(FIVE)(SIX))); // stack overflow if you go much higher (TODO: add trampoline)

let CONS = V;
let FIRST = T(TRUE);
let REST = T(FALSE);
let EMPTY = K(TRUE);
let IS_EMPTY = list => list(_h => _t => FALSE);

let RANGE = Y(f => m => n =>
  LESS_THAN_OR_EQUAL(m)(n)
    (CONS(m)(f(SUCC(m))(n)))
    (EMPTY)
);

let FOLD = Y(f => lst => fn => acc =>
  IS_EMPTY(lst)
    (acc)
    (fn(FIRST(lst))(f(REST(lst))(fn)(acc)))
);

// right fold: combiner :: element -> acc -> acc
let MAP = list => f =>
  FOLD(list)(x => acc => CONS(f(x))(acc))(EMPTY);

let toArray = formatter => list =>
  "[" + (
    Y(go => formatter => lst =>
      IS_EMPTY(lst)
        ("")
        (formatter(FIRST(lst)) +
          (IS_EMPTY(REST(lst))
            ("")
            (", " + go(formatter)(REST(lst)))))
    )
  )(formatter)(list) + "]";

console.log("\nLists:");
console.log("1, 2, 3: " + toArray(toNumber)(
  CONS(ONE)
  (CONS(TWO)(CONS(THREE)(EMPTY)))));
console.log("1..10: " + toArray(toNumber)(RANGE(ONE)(TEN)));
console.log("Sum 1..4 = " + toNumber(FOLD(RANGE(ONE)(FOUR))(ADD)(ZERO)));
console.log("1, 2, 3, incremented = " + toArray(toNumber)(MAP(RANGE(ONE)(THREE))(SUCC)));
// -> [2, 3, 4]

let LETTERS_LINKED_LIST =
  CONS("a")(CONS("b")(CONS("c")(CONS("d")(CONS("e")(
  CONS("f")(CONS("g")(CONS("h")(CONS("i")(CONS("j")(
  CONS("k")(CONS("l")(CONS("m")(CONS("n")(CONS("o")(
  CONS("p")(CONS("q")(CONS("r")(CONS("s")(CONS("t")(
  CONS("u")(CONS("v")(CONS("w")(CONS("x")(CONS("y")(
  CONS("z")(EMPTY))))))))))))))))))))))))));

// ARRAY(n) expects n elements one-by-one, then returns a CONS list of them.
// Usage: ARRAY(DECIMAL2(TWO)(SIX))("a")("b")...("z")
let ARRAY = n =>
  (Y(h => n => acc =>
    IS_ZERO(n)
      (acc(EMPTY))                                // done: apply the builder to EMPTY to materialize the list
      (x => h(PRED(n))(t => acc(CONS(x)(t))) )    // collect x by composing onto the builder
  ))(n)(t => t);                                   // start with identity builder

let LETTERS =
  ARRAY(DECIMAL2(THREE)(SIX))
  ("a")("b")("c")("d")("e")("f")("g")("h")("i")("j")
  ("k")("l")("m")("n")("o")("p")("q")("r")("s")("t")
  ("u")("v")("w")("x")("y")("z")
  ("0")("1")("2")("3")("4")("5")("6")("7")("8")("9");

let NTH = Y(f => n => lst =>
  IS_ZERO(n)
    (FIRST(lst))
    (f(PRED(n))(REST(lst))));

let toString = Y(f => lst =>
  IS_EMPTY(lst)
    ("")
    (NTH(PRED(FIRST(lst)))(LETTERS) + f(REST(lst))));

let CHAR_A  = ONE;
let CHAR_B  = TWO;
let CHAR_C  = THREE;
let CHAR_D  = FOUR;
let CHAR_E  = FIVE;
let CHAR_F  = SIX;
let CHAR_G  = SEVEN;
let CHAR_H  = EIGHT;
let CHAR_I  = NINE;
let CHAR_J  = TEN;
let CHAR_K  = DECIMAL2(ONE)(ONE);   // 11
let CHAR_L  = DECIMAL2(ONE)(TWO);   // 12
let CHAR_M  = DECIMAL2(ONE)(THREE); // 13
let CHAR_N  = DECIMAL2(ONE)(FOUR);  // 14
let CHAR_O  = DECIMAL2(ONE)(FIVE);  // 15
let CHAR_P  = DECIMAL2(ONE)(SIX);   // 16
let CHAR_Q  = DECIMAL2(ONE)(SEVEN); // 17
let CHAR_R  = DECIMAL2(ONE)(EIGHT); // 18
let CHAR_S  = DECIMAL2(ONE)(NINE);  // 19
let CHAR_T  = DECIMAL2(TWO)(ZERO);  // 20
let CHAR_U  = DECIMAL2(TWO)(ONE);   // 21
let CHAR_V  = DECIMAL2(TWO)(TWO);   // 22
let CHAR_W  = DECIMAL2(TWO)(THREE); // 23
let CHAR_X  = DECIMAL2(TWO)(FOUR);  // 24
let CHAR_Y  = DECIMAL2(TWO)(FIVE);  // 25
let CHAR_Z  = DECIMAL2(TWO)(SIX);   // 26
let CHAR_0 = DECIMAL2(TWO)(SEVEN);
let CHAR_1 = DECIMAL2(TWO)(EIGHT);
let CHAR_2 = DECIMAL2(TWO)(NINE);
let CHAR_3 = DECIMAL2(THREE)(ZERO);   // 30
let CHAR_4 = DECIMAL2(THREE)(ONE);    // 31
let CHAR_5 = DECIMAL2(THREE)(TWO);    // 32
let CHAR_6 = DECIMAL2(THREE)(THREE);  // 33
let CHAR_7 = DECIMAL2(THREE)(FOUR);   // 34
let CHAR_8 = DECIMAL2(THREE)(FIVE);   // 35
let CHAR_9 = DECIMAL2(THREE)(SIX);    // 36

let FIZZ = ARRAY(FOUR)(CHAR_F)(CHAR_I)(CHAR_Z)(CHAR_Z);
let BUZZ = ARRAY(FOUR)(CHAR_B)(CHAR_U)(CHAR_Z)(CHAR_Z);
let FIZZBUZZ = APPEND(FIZZ)(BUZZ);

// right fold append
let APPEND =
  Y(f => xs => ys =>
    IS_EMPTY(xs)
      (ys)
      (CONS(FIRST(xs))(f(REST(xs))(ys))));

console.log("\nStrings:");
console.log("The string \"fizz\": " + toString(FIZZ));
console.log("The string \"buzz\": " + toString(BUZZ));
console.log("The string \"fizz\" + \"buzz\": " + toString(FIZZBUZZ));

// DIVIDE m n = floor(m / n); clamp divide-by-zero to 0
let DIVIDE =
  Y(f => m => n =>
    IS_ZERO(n)
      (ZERO)                                   // safe clamp
      (LESS_THAN(m)(n)
        (ZERO)                                 // m < n  => 0
        (SUCC(f(SUBTRACT(m)(n))(n)))));        // else 1 + div(m-n, n)

let REVERSE =
  Y(f => xs =>
    IS_EMPTY(xs)
      (EMPTY)
      (APPEND(f(REST(xs)))(CONS(FIRST(xs))(EMPTY))));

let DIGITS_NUMERAL =
  CONS(CHAR_0)(CONS(CHAR_1)(CONS(CHAR_2)(CONS(CHAR_3)(CONS(CHAR_4)(
  CONS(CHAR_5)(CONS(CHAR_6)(CONS(CHAR_7)(CONS(CHAR_8)(CONS(CHAR_9)(EMPTY))))))))));

// TODO - derive from nth
let NTH0 = Y(f => n => lst =>
  IS_ZERO(n)
    (FIRST(lst))
    (f(PRED(n))(REST(lst))));

let NUMBER_TO_DIGIT_LIST = Y(rec => n =>
  IS_ZERO(DIVIDE(n)(TEN))
    (CONS(MOD(n)(TEN))(EMPTY))
    (APPEND(rec(DIVIDE(n)(TEN)))(CONS(MOD(n)(TEN))(EMPTY))));

let DIGIT_TO_NUMERAL = d => NTH0(d)(DIGITS_NUMERAL);

let NUMBER_TO_STRING =
  n => FOLD(NUMBER_TO_DIGIT_LIST(n))(d => acc => CONS(DIGIT_TO_NUMERAL(d))(acc))(EMPTY);

console.log("Seventy-eight as a string: " + toString(NUMBER_TO_STRING(DECIMAL2(SEVEN)(EIGHT))));

let toLines = Y(go => formatter => lst =>
      IS_EMPTY(lst)
        ("")
        (formatter(FIRST(lst)) +
          (IS_EMPTY(REST(lst))
            ("")
            ("\n" + go(formatter)(REST(lst)))))
    );

let FIFTEEN = DECIMAL2(ONE)(FIVE);

console.log("\n=== THE GRAND FINALE ===");
console.log("\nFizzBuzz:");

let OUTPUT = MAP(RANGE(ONE)(ONE_HUNDRED))(n => IF(
  IS_ZERO(MOD(n)(FIFTEEN))
  	(FIZZBUZZ)
  	(IF(IS_ZERO(MOD(n)(THREE))
        (FIZZ)
        (IF(IS_ZERO(MOD(n)(FIVE))
            (BUZZ)
            (NUMBER_TO_STRING(n))
            ))))));

console.log(toLines(toString)(OUTPUT));

// Exercises for the reader
// 1. Write a function that, given a lambda calculus expression, automatically derives a correct SK combinator expression.

