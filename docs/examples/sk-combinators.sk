// SK Combinator Calculus
// The foundation of computation using only two combinators

// Basic combinators
let S = x => y => z => x(z)(y(z));
let K = x => y => x;

// The identity combinator derived from S and K
let I = S(K)(K);

console.log("Testing basic combinators:");
console.log(I(42));        // Identity: returns 42
console.log(K(10)(20));    // Constant: returns 10

// Boolean logic using combinators
let TRUE = K;
let FALSE = K(I);
let NOT = p => p(FALSE)(TRUE);
let AND = p => q => p(q)(FALSE);
let OR = p => q => p(TRUE)(q);

// More derived combinators (with their lambda forms)
let B = S(K(S))(K);        // Bluebird: x => y => z => x(y(z)) - composition
let C = S(B(B)(S))(K(K));  // Cardinal: x => y => z => x(z)(y) - flip arguments
let W = S(S)(K(I));        // Warbler: x => y => x(y)(y) - duplicate argument
let M = S(I)(I);           // Mockingbird: x => x(x) - self-application
let T = C(I);              // Thrush: x => y => y(x) - flip (simpler than C)
let V = B(C)(T);           // Vireo: x => y => z => z(x)(y) - pair/vireo
let C_STAR = B(C);         // Cardinal once removed: x => y => z => w => x(y)(w)(z)
let C_STAR_STAR = B(C_STAR); // Cardinal twice removed: x => y => z => w => v => x(y)(z)(v)(w)
let R_STAR = C_STAR(C_STAR); // Robin once removed: x => y => z => w => x(z)(w)(y)

// Lazy evaluation test - M(M) would diverge with eager evaluation
console.log("\nLazy evaluation test:");
console.log(K(42)(M(M)));  // Returns 42 without evaluating M(M)

// Barendregt numerals
let ZERO = I;
let IS_ZERO = T(TRUE);     // IS_ZERO n = n TRUE
let SUCC = V(FALSE);        // SUCC n = V FALSE n
let PRED = T(FALSE);        // PRED n = n FALSE

// Build some numbers
let ONE = SUCC(ZERO);
let TWO = SUCC(ONE);
let THREE = SUCC(TWO);
let FOUR = SUCC(THREE);
let FIVE = SUCC(FOUR);

// Convert Barendregt numeral to JavaScript number
let toNumber = n => IS_ZERO(n)(0)(1 + toNumber(PRED(n)));

console.log("\nBarendregt numerals:");
console.log(toNumber(ZERO));   // 0
console.log(toNumber(THREE));  // 3
console.log(toNumber(FIVE));   // 5

// Y combinator for recursion
// let Y = f => (x => f(x(x)))(x => f(x(x)));
let Y = W(C)(S(B)(C(W(C))));

// Addition
// Starting from Lambda Calculus (more readable, way less metal)
// let ADD = Y(f => m => n => IS_ZERO(n)(m)(SUCC(f(PRED(n))(m))));
// First eliminate m
// ADD(n)(m) = IS_ZERO(n)(m)(SUCC(ADD(PRED(n))(m)))
// ADD(n)(m) = B(IS_ZERO(n)(m))(SUCC)(ADD(PRED(n))(m))
// ADD(n)(m) = B(B)(IS_ZERO(n))(m)(SUCC)(ADD(PRED(n))(m))
// ADD(n)(m) = C(B(B)(IS_ZERO(n)))(SUCC)(m)(ADD(PRED(n))(m))
// ADD(n)(m) = S(C(B(B)(IS_ZERO(n)))(SUCC))(ADD(PRED(n)))(m)
// Then eliminate n
// ADD(n)(m) = S(C(B(B(B))(IS_ZERO)(n))(SUCC))(ADD(PRED(n)))(m)
// ADD(n)(m) = S(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)(n))(ADD(PRED(n)))(m)
// ADD(n)(m) = B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))(n)(B(ADD)(PRED)(n))(m)
// ADD(n)(m) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(B(ADD)(PRED))(n)(m)
// Then eliminate the explicit self reference
// ADD_MAKER(y)(n)(m) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(B(y)(PRED))(n)(m)
// ADD_MAKER(y)(n)(m) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(K(I)(y)(B(y))(PRED))(n)(m)
// ADD_MAKER(y)(n)(m) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(S(K(I))(B)(y)(PRED))(n)(m)
// ADD_MAKER(y)(n)(m) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(C(S(K(I))(B))(PRED)(y))(n)(m)
// ADD_MAKER(y)(n)(m) = B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED))(y)(n)(m)
let ADD = Y(B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED)));

console.log("\nAddition with combinators:");
console.log(toNumber(ADD(TWO)(THREE)));  // 5
console.log(toNumber(ADD(FOUR)(FIVE)));  // 9
