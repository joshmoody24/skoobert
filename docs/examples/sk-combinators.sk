// SK Combinator Calculus
// The foundation of computation using only two combinators

// Basic combinators
let S = x => y => z => x(z)(y(z));   // Duplication and reordering
let K = x => y => x;                 // Constants and ignoring
let I = S(K)(K);                     // Identity

console.log("Basic combinators:");
console.log("Identify combinator: 42 = " + I(42));            // Identity: returns 42
console.log("Kestral combinator: K(10)(20) = " + K(10)(20));  // Constant: returns 10

// General purpose derived combinators
let B = S(K(S))(K);          // Bluebird:     x => y => z => x(y(z))              - composition
let C = S(B(B)(S))(K(K));    // Cardinal:     x => y => z => x(z)(y)              - flip last two arguments
let W = S(S)(K(I));          // Warbler:      x => y => x(y)(y)                   - duplicate argument
let M = S(I)(I);             // Mockingbird:  x => x(x)                           - self-application
let T = C(I);                // Thrush:       x => y => y(x)                      - flip arguments
let V = B(C)(T);             // Vireo:        x => y => z => z(x)(y)              - move last argument to front
let R = B(B)(T);             // Robin:        x => y => z => y(z)(x)              - move middle argument to front
let Y = W(C)(S(B)(C(W(C)))); // Y Combinator: x => (y => x(y(y)))(y => x(y(y)));  - recursion (see also LxLx, UU, and many other equivalents)
let B1 = B(B)(B);            // Blackbird:    x => y => z => w => x(y(b)(w))
let E = B(B1);               // Eagle:        x => y => z => w => v => x(y)(z(w(v)))
let R_STAR = C_STAR(C_STAR); // Robin once removed:     x => y => z => w => x(z)(w)(y)          - AKA R*
let C_STAR = B(C);           // Cardinal once removed:  x => y => z => w => x(y)(w)(z)          - AKA C*
let C_STAR_STAR = B(C_STAR); // Cardinal twice removed: x => y => z => w => v => x(y)(z)(v)(w)  - AKA C**

// Boolean logic
let TRUE = K;      // given two things, choose the first
let FALSE = K(I);  // given two things, choose the second
let IF = I;

let extractBoolean = V(true)(false); // helper function to make booleans human-readable

let NOT = V(FALSE)(TRUE); // NOT = p => p(FALSE)(TRUE);

console.log("\nBoolean logic:");
console.log("NOT true = " + extractBoolean(NOT(TRUE)));
console.log("NOT false = " + extractBoolean(NOT(FALSE)));

// Lazy evaluation test - M(M) would diverge with eager evaluation
console.log("\nLazy evaluation test:");
console.log(K(42)(M(M)) + " (this would throw an error in normal JavaScript)");  // Returns 42 without evaluating M(M)

// Barendregt/Scott numerals
let ZERO = I;
let IS_ZERO = T(TRUE);      // IS_ZERO n = n TRUE
let SUCC = V(FALSE);        // SUCC n = V FALSE n
let PRED = T(FALSE);        // PRED n = n FALSE
let DECREMENT = m => IS_ZERO(m)(m)(PRED(m)); // Clamped version of PRED

// Build some numbers
let ONE   = SUCC(ZERO);
let TWO   = SUCC(ONE);
let THREE = SUCC(TWO);
let FOUR  = SUCC(THREE);
let FIVE  = SUCC(FOUR);
let SIX   = SUCC(FIVE);
let SEVEN = SUCC(SIX);
let EIGHT = SUCC(SEVEN);
let NINE  = SUCC(EIGHT);
let TEN   = SUCC(NINE);

let nativeIncrement = x => x + 1; // only used for printing to console

// Convert Barendregt/Scott numeral to native number
// let extractNumber = m => IS_ZERO(m)(0)(1 + toNumber(PRED(m)));
let extractNumber = Y(B(S(C(IS_ZERO)(0)))(B(B(nativeIncrement))(C(B)(PRED))));

console.log("\nBarendregt/Scott numerals:");
console.log("One: " + extractNumber(ZERO));     // 0
console.log("Three: " + extractNumber(THREE));  // 3
console.log("Five: " + extractNumber(FIVE));    // 5

// Addition
// Starting from Lambda Calculus (more readable, way less metal)
// let ADD = m => n => IS_ZERO(m)(n)(SUCC(ADD(PRED(m))(n)));
// First eliminate n
// ADD(m)(n) = IS_ZERO(m)(n)(SUCC(ADD(PRED(m))(n)))
// ADD(m)(n) = B(IS_ZERO(m)(n))(SUCC)(ADD(PRED(m))(n))
// ADD(m)(n) = B(B)(IS_ZERO(m))(n)(SUCC)(ADD(PRED(m))(n))
// ADD(m)(n) = C(B(B)(IS_ZERO(m)))(SUCC)(n)(ADD(PRED(m))(n))
// ADD(m)(n) = S(C(B(B)(IS_ZERO(m)))(SUCC))(ADD(PRED(m)))(n)
// Then eliminate m
// ADD(m)(n) = S(C(B(B(B))(IS_ZERO)(m))(SUCC))(ADD(PRED(m)))(n)
// ADD(m)(n) = S(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)(m))(ADD(PRED(m)))(n)
// ADD(m)(n) = B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))(m)(B(ADD)(PRED)(m))(n)
// ADD(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(B(ADD)(PRED))(m)(n)
// Then eliminate the explicit self reference
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(B(y)(PRED))(m)(n)
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(K(I)(y)(B(y))(PRED))(m)(n)
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(S(K(I))(B)(y)(PRED))(m)(n)
// ADD_MAKER(y)(m)(n) = S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC)))(C(S(K(I))(B))(PRED)(y))(m)(n)
// ADD_MAKER(y)(m)(n) = B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED))(y)(m)(n)
// ADD_MAKER = B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED))
// ADD = Y(ADD_MAKER)
let ADD = Y(B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(SUCC))))(C(S(K(I))(B))(PRED)));

console.log("\nAddition:");
console.log("2 + 3 = " + extractNumber(ADD(TWO)(THREE)));  // 5
console.log("4 + 5 = " + extractNumber(ADD(FOUR)(FIVE)));  // 9

// Subtraction
// Same as ADD except with DECREMENT instead of SUCC, and wrapped in C to swap the params
let SUBTRACT = C(Y(B(S(B(S)(C_STAR_STAR(B)(C)(B(B(B))(IS_ZERO))(DECREMENT))))(C(S(K(I))(B))(PRED))));

console.log("\nSubtraction:");
console.log("5 - 2 = " + extractNumber(SUBTRACT(FIVE)(TWO)));  // 3
console.log("1 - 3 = " + extractNumber(SUBTRACT(ONE)(THREE)) + " (no negatives in this number system)");  // 0

// let MULTIPLY = (x) => (y) => IS_ZERO(y)(ZERO)(ADD(x)(MULTIPLY(x)(PRED(y))));
let MULTIPLY = C(S(B(B)(C(IS_ZERO)(ZERO)))(B(S(ADD))(B(C(MULTIPLY))(PRED))));

console.log("\nMultiplication:");
console.log("5 * 5 = " + extractNumber(MULTIPLY(FIVE)(FIVE)));
console.log("3 * 4 = " + extractNumber(MULTIPLY(THREE)(FOUR)));
console.log("2 * 0 = " + extractNumber(MULTIPLY(TWO)(ZERO)));

// LESS_THAN_OR_EQUAL(a)(b) = IS_ZERO(SUBTRACT(a)(b))(TRUE)(FALSE)
// LESS_THAN_OR_EQUAL(a)(b) = IS_ZERO(SUBTRACT(a)(b))
// LESS_THAN_OR_EQUAL(a)(b) = B1(IS_ZERO)(SUBTRACT)
let LESS_THAN_OR_EQUAL = B1(IS_ZERO)(SUBTRACT);
let GREATER_THAN_OR_EQUAL = C(LESS_THAN_OR_EQUAL);

console.log("\nLess than or equal:");
console.log("3 <= 2 = " + extractBoolean(LESS_THAN_OR_EQUAL(THREE)(TWO)));  // true
console.log("4 <= 5 = " + extractBoolean(LESS_THAN_OR_EQUAL(FOUR)(FIVE)));  // false
console.log("0 <= 0 = " + extractBoolean(LESS_THAN_OR_EQUAL(FOUR)(FIVE)));  // false

let INVERT_BINARY_RELATION = B1(NOT);
let GREATER_THAN = INVERT_BINARY_RELATION(LESS_THAN_OR_EQUAL);
let LESS_THAN = INVERT_BINARY_RELATION(GREATER_THAN_OR_EQUAL);

console.log("\nGreater than:");
console.log("3 > 2 = " + extractBoolean(GREATER_THAN(THREE)(TWO)));  // true
console.log("4 > 5 = " + extractBoolean(GREATER_THAN(FOUR)(FIVE)));  // false
console.log("0 > 0 = " + extractBoolean(GREATER_THAN(FOUR)(FIVE)));  // false

// let MOD = m => n => LESS_THAN(m)(n)(m)(MOD(SUBTRACT(m)(n))(n));
// First eliminate n
// let MOD = m => n => S(W(C_STAR(LESS_THAN))(m))(W(B(MOD)(SUBTRACT(m))))(n);
// let MOD = m => S(W(C_STAR(LESS_THAN))(m))(W(B(MOD)(SUBTRACT(m))));
// Then eliminate m
// let MOD = m => S(B(S)(W(C_STAR(LESS_THAN))))(B(W)(B(B(MOD))(SUBTRACT)))(m);
// let MOD = S(B(S)(W(C_STAR(LESS_THAN))))(B(W)(B(B(MOD))(SUBTRACT)));
// Then eliminate the explicit self reference
// let MOD_MAKER = self => S(B(S)(W(C_STAR(LESS_THAN))))(B(W)(B(B(self))(SUBTRACT)));
// let MOD_MAKER = self => B(S(B(S)(W(C_STAR(LESS_THAN)))))(B(B(W))(C(B(B)(B))(SUBTRACT)))(self);
// let MOD_MAKER = B(S(B(S)(W(C_STAR(LESS_THAN)))))(B(B(W))(C(B(B)(B))(SUBTRACT)));
// let MOD = Y(MOD_MAKER);

// RECURSE_SUB is a common piece of logic shared by DIVIDE, there it is extracted into its own variable.
// This was discovered after deriving both of them from scratch.
// There is probably some deep elegance here that is lost on me.
let RECURSE_SUB = B(B(W))(C(B(B)(B))(SUBTRACT));
let MOD = Y(B(S(B(S)(W(C_STAR(LESS_THAN)))))(RECURSE_SUB));

console.log("\nModulus:");
console.log("5 % 2 = " + extractNumber(MOD(FIVE)(TWO)));
console.log("5 % 3 = " + extractNumber(MOD(FIVE)(THREE)));
console.log("4 % 2 = " + extractNumber(MOD(FOUR)(TWO)));

// DIVIDE m n = floor(m / n); clamp divide-by-zero to 0
// let DIVIDE =
//   Y(f => m => n =>
//     IS_ZERO(n)
//       (ZERO)
//       (LESS_THAN(m)(n)
//         (ZERO)
//         (SUCC(f(SUBTRACT(m)(n))(n)))));
let DIVIDE =
  Y(B(B(S(C(IS_ZERO)(ZERO))))(B(S(B(S)(C(B(C)(LESS_THAN))(ZERO))))(B(B(B(SUCC)))(RECURSE_SUB))));
console.log("\nDivision:");
console.log("4 / 2 = " + extractNumber(DIVIDE(FOUR)(TWO)));    // 2
console.log("5 / 3 = " + extractNumber(DIVIDE(FIVE)(THREE)));  // 1
console.log("3 / 0 = " + extractNumber(DIVIDE(THREE)(ZERO)));  // 0

let DECIMAL2 = B(ADD)(MULTIPLY(TEN)); // x => y => ADD(MULTIPLY(TEN)(x))(y);

let ONE_HUNDRED = MULTIPLY(TEN)(TEN);
let DECIMAL3 = C(E(B(ADD)(MULTIPLY(ONE_HUNDRED))))(DECIMAL2); // x => y => z => ADD(MULTIPLY(ONE_HUNDRED)(DECIMAL2(y)(z));

console.log("\nDecimal numbers:");
console.log("Twenty-six: " + extractNumber(DECIMAL2(TWO)(SIX)));
console.log("Two hundred fifty-six: " + extractNumber(DECIMAL3(TWO)(FIVE)(SIX))); // stack overflow if you go much higher (TODO: add trampoline)

// lists
let CONS = V;                  // Used to create a linked list
let FIRST = T(TRUE);           // Gets the first element in a list
let REST = T(FALSE);           // Gets everything in a list except the first element
let EMPTY = K(TRUE);           // An empty list, as in [], also used to denote the end of a list
let END = EMPTY;               // Interchangeable with EMPTY, whichever is more readable
let IS_EMPTY = T(K(K(FALSE))); // let IS_EMPTY = list => list(x => y => FALSE);

// 0-based list index access
// let NTH = lst => n =>
//   IS_ZERO(n)
//    (FIRST(lst))
//    (NTH(REST(lst))(PRED(n)));
let NTH = Y(B(S(B(S)(B(C(IS_ZERO))(FIRST))))(C(B(C)(B(B(B))(C(B)(REST))))(PRED)));

// let CONCAT = xs => ys => (FOLD(xs))(CONS)(ys);
let CONCAT = B(T(CONS))(FOLD);

// let REVERSE = xs =>
//     IS_EMPTY(xs)
//       (EMPTY)
//       (CONCAT(REVERSE(REST(xs)))(CONS(FIRST(xs))(EMPTY)));
let REVERSE = Y(B(S(C(IS_EMPTY)(EMPTY)))(C(B(S)(B(B(CONCAT))(C(B)(REST))))(C(B(CONS)(FIRST))(EMPTY))));

//let RANGE = Y(f => m => n =>
//  LESS_THAN_OR_EQUAL(m)(n)
//    (CONS(m)(f(SUCC(m))(n)))
//    (EMPTY)
//);
let RANGE = Y(C(B(C)(B(B(C))(B(S(B(S)(LESS_THAN_OR_EQUAL)))(B(S(B(B)(CONS)))(C(B)(SUCC))))))(EMPTY));

// let FOLD = Y(f => lst => fn => acc =>
//   IS_EMPTY(lst)
//     (acc)
//     (fn(FIRST(lst))(f(REST(lst))(fn)(acc)))
// );
let FOLD = Y(B(S(B(B)(B(S)(IS_EMPTY))))(B(S(B(S)(C(B(B(B))(C(B)(FIRST))))))(C(B)(REST))));

// let MAP = lst => f => FOLD(lst)(x => acc => CONS(f(x))(acc))(EMPTY);
let MAP = C(B(C)(C(B(B)(FOLD))(B(CONS))))(EMPTY);

// Not going to bother making this point-free,
// since it's just for printing to the console.
let commaSeparated = formatter => lst =>
      IS_EMPTY(lst)
        ("")
        (formatter(FIRST(lst)) +
          (IS_EMPTY(REST(lst))
            ("")
            (", " + commaSeparated(formatter)(REST(lst)))));

let extractArray = formatter => list => "[" + (commaSeparated)(formatter)(list) + "]";

console.log("\nLists:");
console.log("[1, 2, 3]: " + extractArray(extractNumber)(CONS(ONE)(CONS(TWO)(CONS(THREE)(END)))));
console.log("[7, 8, 9] reversed: " + extractArray(extractNumber)(REVERSE(CONS(SEVEN)(CONS(EIGHT)(CONS(NINE)(END))))));
console.log("Second element in [1, 2]: " + extractNumber(
  NTH(CONS(ONE)(CONS(TWO)(END)))(ONE)
));
console.log("1..10: " + extractArray(extractNumber)(RANGE(ONE)(TEN)));
console.log("Sum 1..4 = " + extractNumber(FOLD(RANGE(ONE)(FOUR))(ADD)(ZERO)));
console.log("Increment 1..3 = " + extractArray(extractNumber)(MAP(RANGE(ONE)(THREE))(SUCC)));

// strings

// let ARRAY = Y(h => cont => x =>
//   IS_EMPTY(x)
//     (cont(END))                         // finish: run the continuation on END
//     (h(y => cont(CONS(x)(y))))          // keep chaining: prepend x later
// (I);
// Usage: `ARRAY(ONE)(TWO)(THREE)(END)`
// More ergonomic than `CONS(ONE)(CONS(TWO)(CONS(THREE)(CONS(END))))`
let ARRAY = Y(B(S(B(S)(C(B(C(IS_EMPTY)))(END))))(C(B(B)(B))(C(B(B)(B))(CONS))))(I);

let CHAR_A  = ONE;
let CHAR_B  = TWO;
let CHAR_C  = THREE;
let CHAR_D  = FOUR;
let CHAR_E  = FIVE;
let CHAR_F  = SIX;
let CHAR_G  = SEVEN;
let CHAR_H  = EIGHT;
let CHAR_I  = NINE;
let CHAR_J  = TEN;
let CHAR_K  = DECIMAL2(ONE)(ONE);   // 11
let CHAR_L  = DECIMAL2(ONE)(TWO);   // 12
let CHAR_M  = DECIMAL2(ONE)(THREE); // 13
let CHAR_N  = DECIMAL2(ONE)(FOUR);  // 14
let CHAR_O  = DECIMAL2(ONE)(FIVE);  // 15
let CHAR_P  = DECIMAL2(ONE)(SIX);   // 16
let CHAR_Q  = DECIMAL2(ONE)(SEVEN); // 17
let CHAR_R  = DECIMAL2(ONE)(EIGHT); // 18
let CHAR_S  = DECIMAL2(ONE)(NINE);  // 19
let CHAR_T  = DECIMAL2(TWO)(ZERO);  // 20
let CHAR_U  = DECIMAL2(TWO)(ONE);   // 21
let CHAR_V  = DECIMAL2(TWO)(TWO);   // 22
let CHAR_W  = DECIMAL2(TWO)(THREE); // 23
let CHAR_X  = DECIMAL2(TWO)(FOUR);  // 24
let CHAR_Y  = DECIMAL2(TWO)(FIVE);  // 25
let CHAR_Z  = DECIMAL2(TWO)(SIX);   // 26
let CHAR_0 = DECIMAL2(TWO)(SEVEN);
let CHAR_1 = DECIMAL2(TWO)(EIGHT);
let CHAR_2 = DECIMAL2(TWO)(NINE);
let CHAR_3 = DECIMAL2(THREE)(ZERO);
let CHAR_4 = DECIMAL2(THREE)(ONE);
let CHAR_5 = DECIMAL2(THREE)(TWO);
let CHAR_6 = DECIMAL2(THREE)(THREE);
let CHAR_7 = DECIMAL2(THREE)(FOUR);
let CHAR_8 = DECIMAL2(THREE)(FIVE);
let CHAR_9 = DECIMAL2(THREE)(SIX);

let FIZZ = ARRAY(CHAR_F)(CHAR_I)(CHAR_Z)(CHAR_Z)(END);
let BUZZ = ARRAY(CHAR_B)(CHAR_U)(CHAR_Z)(CHAR_Z)(END);
let FIZZBUZZ = CONCAT(FIZZ)(BUZZ);

// String utility functions
// (only used for printing to the console)
let array =
  (Y(h => acc => x =>
    x === END
      ? acc(END)
      : h(t => acc(CONS(x)(t)))))
  (I);

let letters =
  array
  ("a")("b")("c")("d")("e")("f")("g")("h")("i")("j")
  ("k")("l")("m")("n")("o")("p")("q")("r")("s")("t")
  ("u")("v")("w")("x")("y")("z")
  ("0")("1")("2")("3")("4")("5")("6")("7")("8")("9")(END);

let extractString = Y(f => lst =>
  IS_EMPTY(lst)
    ("")
    (NTH(letters)(PRED(FIRST(lst))) + f(REST(lst)))
);

console.log("\nStrings:");
console.log("The string \"fizz\": " + extractString(FIZZ));
console.log("The string \"buzz\": " + extractString(BUZZ));
console.log("The string \"fizz\" + \"buzz\": " + extractString(FIZZBUZZ));

let DIGITS_NUMERAL = ARRAY
	(CHAR_0)(CHAR_1)(CHAR_2)
	(CHAR_3)(CHAR_4)(CHAR_5)
	(CHAR_6)(CHAR_7)(CHAR_8)
	(CHAR_9)(END);

// let NUMBER_TO_DIGIT_LIST = n =>
//   IS_ZERO(DIVIDE(n)(TEN))
//     (CONS(MOD(n)(TEN))(EMPTY))
//     (CONCAT(NUMBER_TO_DIGIT_LIST(DIVIDE(n)(TEN)))(CONS(MOD(n)(TEN))(EMPTY)));
// Notice the repeated forms `DIVIDE(n)(TEN)` and `(CONS(MOD(n)(TEN))(EMPTY))`.
// Extracting them into variables may make derivation easier.
let NUMBER_TO_DIGIT_LIST =
  S(B(S(B(S)(IS_ZERO))
    (B(CONCAT)(NUMBER_TO_DIGIT_LIST)))(C(DIVIDE)(TEN)))(C(B(CONS)(C(MOD)(TEN)))(EMPTY));

let DIGIT_TO_NUMERAL = NTH(DIGITS_NUMERAL);

let NUMBER_TO_STRING =
  n => FOLD(NUMBER_TO_DIGIT_LIST(n))(d => acc => CONS(DIGIT_TO_NUMERAL(d))(acc))(EMPTY);

console.log("Seventy-eight as a string: " + extractString(NUMBER_TO_STRING(DECIMAL2(SEVEN)(EIGHT))));

// Converts a list to a string with one element per line
// Only used for printing to the console
let toLines = formatter => lst =>
      IS_EMPTY(lst)
        ("")
        (formatter(FIRST(lst)) +
          (IS_EMPTY(REST(lst))
            ("")
            ("\n" + toLines(formatter)(REST(lst)))));

let FIFTEEN = DECIMAL2(ONE)(FIVE);

console.log("\n=== THE GRAND FINALE ===");
console.log("\nFizzBuzz:");

let OUTPUT = MAP(RANGE(ONE)(ONE_HUNDRED))(n => IF(
  IS_ZERO(MOD(n)(FIFTEEN))
  	(FIZZBUZZ)
  	(IF(IS_ZERO(MOD(n)(THREE))
        (FIZZ)
        (IF(IS_ZERO(MOD(n)(FIVE))
            (BUZZ)
            (NUMBER_TO_STRING(n))
            ))))));

console.log(toLines(extractString)(OUTPUT));

// Exercises for the reader
// 1. Write a function that, given a lambda calculus expression, automatically derives a correct SK combinator expression.
