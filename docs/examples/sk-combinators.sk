// SK Combinator Calculus
// The foundation of computation using only two combinators

// Basic combinators
let S = x => y => z => x(z)(y(z));
let K = x => y => x;

// The identity combinator derived from S and K
let I = S(K)(K);

console.log("Testing basic combinators:");
console.log(I(42));        // Identity: returns 42
console.log(K(10)(20));    // Constant: returns 10

// Boolean logic using combinators
let TRUE = K;
let FALSE = K(I);
let NOT = p => p(FALSE)(TRUE);
let AND = p => q => p(q)(FALSE);
let OR = p => q => p(TRUE)(q);

// More derived combinators (with their lambda forms)
let B = S(K(S))(K);        // Bluebird: x => y => z => x(y(z)) - composition
let C = S(B(B)(S))(K(K));  // Cardinal: x => y => z => x(z)(y) - flip arguments
let W = S(S)(K(I));        // Warbler: x => y => x(y)(y) - duplicate argument
let M = S(I)(I);           // Mockingbird: x => x(x) - self-application
let T = C(I);              // Thrush: x => y => y(x) - flip (simpler than C)
let V = B(C)(T);           // Vireo: x => y => z => z(x)(y) - pair/vireo
let C_STAR = B(C);         // Cardinal once removed: x => y => z => w => x(y)(w)(z)
let R_STAR = C_STAR(C_STAR); // Robin once removed: x => y => z => w => x(z)(w)(y)

// Lazy evaluation test - M(M) would diverge with eager evaluation
console.log("Lazy evaluation test:");
console.log(K(42)(M(M)));  // Returns 42 without evaluating M(M)

// Barendregt numerals
let ZERO = I;
let IS_ZERO = T(TRUE);     // IS_ZERO n = n TRUE
let SUCC = V(FALSE);        // SUCC n = V FALSE n
let PRED = T(FALSE);        // PRED n = n FALSE

// Build some numbers
let ONE = SUCC(ZERO);
let TWO = SUCC(ONE);
let THREE = SUCC(TWO);
let FOUR = SUCC(THREE);
let FIVE = SUCC(FOUR);

// Convert Barendregt numeral to JavaScript number
let toNumber = n => IS_ZERO(n)(0)(1 + toNumber(PRED(n)));

console.log("Barendregt numerals:");
console.log(toNumber(ZERO));   // 0
console.log(toNumber(THREE));  // 3
console.log(toNumber(FIVE));   // 5

// Y combinator for recursion
let Y = W(C)(S(B)(C(W(C))));

// Equivalent in Lambda Calculus (more readable, less metal)
// let Y = f => (x => f(x(x)))(x => f(x(x)));

// Derivation of ADD combinator:
// Start with ADD_ZERO: f => n => IS_ZERO(n)(ZERO)(SUCC(f(PRED(n))))
// In combinator form (with f, n as implicit arguments):
// fn = IS_ZERO(n)(ZERO)(SUCC(f(PRED(n))))
// The goal is to get n by itself on the far right:
// fn = C(IS_ZERO)(ZERO)(n)(SUCC(f(PRED(n))))
// fn = C(IS_ZERO)(ZERO)(n)(SUCC(B(f)(PRED)(n)))
// fn = C(IS_ZERO)(ZERO)(n)(B(SUCC)(B(f)(PRED))(n))
// fn = S(C(IS_ZERO)(ZERO))(B(SUCC)(B(f)(PRED)))(n)
// f = S(C(IS_ZERO)(ZERO))(B(SUCC)(C(B)(PRED)(f)))
// f = S(C(IS_ZERO)(ZERO))(B(B(SUCC))(C(B)(PRED)))(f)
// f = B(S(C(IS_ZERO)(ZERO)))(B(B(SUCC))(C(B)(PRED)))(f)
// ADD_ZERO_X = B(S(C(IS_ZERO)(ZERO)))(B(B(SUCC))(C(B)(PRED)))
//
// Now generalize ZERO to m to get general ADD:
// fmn = B(S(C(IS_ZERO)(m)))(B(B(SUCC))(C(B)(PRED)))(f)(n)
// fmn = B(B(S)(C(IS_ZERO)))(m)(B(B(SUCC))(C(B)(PRED)))(f)(n)
// fmn = B(B)(B(S)(C(IS_ZERO)))(m)(B(B(SUCC))(C(B)(PRED)))(f)(n)
// fmn = T(B(B(SUCC))(C(B)(PRED)))(B(B)(B(S)(C(IS_ZERO)))(m))(f)(n)
// fm = T(B(B(SUCC))(C(B)(PRED)))(B(B)(B(S)(C(IS_ZERO)))(m))(f)
// fm = B(T(B(B(SUCC))(C(B)(PRED))))(B(B)(B(S)(C(IS_ZERO))))(m)(f)
// f = R_STAR(B(T(B(B(SUCC))(C(B)(PRED))))(B(B)(B(S)(C(IS_ZERO)))))
//
// Breaking down into parts:
// P1 = T(B(B(SUCC))(C(B)(PRED)))
// P2 = B(B)(B(S)(C(IS_ZERO)))
// P3 = B(P1)(P2)
// ADD_X = R_STAR(P3)
// ADD = Y(ADD_X)

let P1 = T(B(B(SUCC))(C(B)(PRED)));
let P2 = B(B)(B(S)(C(IS_ZERO)));
let P3 = B(P1)(P2);
// let ADD_X = R_STAR(P3); // theoretically this seems right, but it's not working
// let ADD = Y(ADD_X);
let ADD = (m) => Y(P3(m)); // Sad non-point-free workaround for now :(

// Equivalent in Lambda Calculus (more readable, way less metal)
// let ADD = Y(f => m => n => IS_ZERO(n)(m)(SUCC(f(PRED(n))(m))));

console.log("Addition with combinators:");
console.log(toNumber(ADD(TWO)(THREE)));  // 5
console.log(toNumber(ADD(FOUR)(FIVE)));  // 9
